{"id":1058772341,"lang":"cpp","lang_name":"C++","time":"3 days, 16 hours","timestamp":1695648841,"status":10,"status_display":"Accepted","runtime":"131 ms","url":"/submissions/detail/1058772341/","is_pending":"Not Pending","title":"Contains Duplicate II","memory":"72.6 MB","code":"class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        // map for storing the current window elements\n        unordered_map<int,int> nmap;\n\n        int n = nums.size();\n        int i=0,j=0;\n\n        // at first, filling the 1st window\n        while(j<=k && j<n){\n            int num = nums[j];\n\n            if(nmap.find(num) != nmap.end()){\n                return true;\n            }\n            nmap[num]++;\n\n            j++;\n        }\n\n        // now shifting window size +1 with i,j\n        // also erasing the old i value which is not currently in window\n        nmap.erase(nums[i]);\n        i++;\n\n        while(j < n){\n            int num = nums[j];\n            \n            // check if it in window or not and adding new element in window\n            if(nmap.find(num) != nmap.end()){\n                return true;\n            }\n            nmap[num]++;\n\n            // erase of old window and shift\n            int num2=nums[i];\n            nmap.erase(num2);\n            i++;\n            j++;\n        }\n        return false;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111","title_slug":"contains-duplicate-ii","has_notes":true,"flag_type":1}